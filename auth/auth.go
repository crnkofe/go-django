// Package auth implements read-only access to
// cookies generated by Django's signed_cookies session backend.
package auth

import (
	"bytes"
	"compress/zlib"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"hash"
	"io/ioutil"
	"strings"
	"time"
)

type Session struct {
	maxAge    time.Duration
	secret    string
	salt      string
	fnHash    func() hash.Hash
	separator []byte
}

func NewSession(maxAge time.Duration, secret string, salt string, fnHash func() hash.Hash, separator []byte) *Session {
	return &Session{
		maxAge:    maxAge,
		secret:    secret,
		salt:      salt,
		fnHash:    fnHash,
		separator: separator,
	}
}

func NewDefaultSession(secret string) *Session {
	return &Session{
		maxAge:    14 * 24 * time.Hour,
		secret:    secret,
		salt:      "django.contrib.sessions.SessionStore",
		fnHash:    sha256.New,
		separator: []byte{':'},
	}
}

// Decode implements cookie object decoding in a way that is
// compatible with django.core.signing.loads.  It returns a map
// representing the encoded object, or an error if one occurred.
func (s Session) Decode(cookie string) (map[string]interface{}, error) {
	c := []byte(cookie) // XXX: does this escape?
	payload, err := timestampUnsign(s.maxAge, s.secret, c, s.salt, s.fnHash, s.separator)
	if err != nil {
		return nil, fmt.Errorf("timestampUnsign: %s", err)
	}
	decompress := false
	if payload[0] == '.' {
		decompress = true
		payload = payload[1:]
	}
	payload, err = b64Decode(payload)
	if err != nil {
		return nil, fmt.Errorf("base64Decode('%s'): %s", string(payload), err)
	}
	if decompress {
		r, err := zlib.NewReader(bytes.NewReader(payload))
		if err != nil {
			return nil, fmt.Errorf("zlib.NewReader: %s", err)
		}
		payload, err = ioutil.ReadAll(r)
		err = r.Close()
		if err != nil {
			return nil, fmt.Errorf("ReadAll(zlib): %s", err)
		}
	}
	o := make(map[string]interface{})
	err = json.Unmarshal(payload, &o)
	return o, err
}

// b64Encode encodes a slice of bytes in a Django-compatible way,
// trimming trailing '=' padding specified by the standard.
func b64Encode(b []byte) ([]byte, error) {
	var buf bytes.Buffer
	encoder := base64.NewEncoder(base64.URLEncoding, &buf)
	_, err := encoder.Write(b)
	if err != nil {
		return []byte{}, err
	}
	err = encoder.Close()
	if err != nil {
		return []byte{}, err
	}
	return bytes.TrimRight(buf.Bytes(), "="), nil
}

// b64Decode decodes a base64-encoded string that was generated by
// Django - specifically it adds any '=' padding that had previously
// been stripped back to the end of the byte slice to ensure Go's
// base64 decoder reads the entire payload.
func b64Decode(b []byte) ([]byte, error) {
	// Django's signing module strips all '=' padding from its
	// encoded representation of b.  Add them back here.
	pad := 4 - len(b)%4
	if pad == 4 {
		pad = 0
	}
	for i := 0; i < pad; i++ {
		// append is ideal here, because we can overwrite the
		// timestamp that immediately follows the payload and
		// avoid an allocation.
		b = append(b, '=')
	}
	return ioutil.ReadAll(base64.NewDecoder(base64.URLEncoding, bytes.NewReader(b)))
}

var (
	base62Alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
)

// b62decode decodes a base62-encoded string into an int64, using the
// same method as Django's django.utils.baseconv.BaseConverter.
func b62Decode(b []byte) (int64, error) {
	var n int64
	for _, d := range b {
		i := strings.IndexByte(base62Alphabet, d)
		if i < 0 {
			return -1, fmt.Errorf("not base62 encoded")
		}
		n = n*int64(len(base62Alphabet)) + int64(i)
	}
	return n, nil
}

// djangoSignature calculates a HMAC signature in a way that matches
// django.core.signing.Signer.signature().
func djangoSignature(salt string, value []byte, secret string, fnHash func() hash.Hash) ([]byte, error) {
	// explicit make + append instead of
	// []byte(salt+"signer"+secret) avoids an allocation. copy
	// instead of append doesn't change allocation count.

	key := make([]byte, 0, len(salt)+len("signer")+len(secret))
	key = append(key, salt...)
	key = append(key, "signer"...)
	key = append(key, secret...)
	mac := hmac.New(fnHash, key)
	mac.Write(value)
	return b64Encode(mac.Sum(nil))
}

// unsign returns the cookie payload if the signature matches the
// expected signature using the given secret, or an error otherwise.
func unsign(secret string, cookie []byte, salt string, fnHash func() hash.Hash, separator []byte) ([]byte, error) {
	i := bytes.LastIndex(cookie, separator)
	if i == -1 {
		return nil, fmt.Errorf("expected : in '%s'", string(cookie))
	}
	val := cookie[:i]
	sig := cookie[i+1:]
	expectedSig, err := djangoSignature(salt, val, secret, fnHash)
	if err != nil {
		return []byte{}, err
	}
	if !hmac.Equal(expectedSig, sig) {
		return nil, fmt.Errorf("signature mismatch: '%s' != '%s'", sig, string(expectedSig))
	}
	return val, nil
}

var now = time.Now

// timestampUnsign returns the cookie payload if the signature matches
// the expected signature using the given secret, and the timestamp of
// the cookie is still valid.  It wraps the unsign method.
func timestampUnsign(maxAge time.Duration, secret string, cookie []byte, salt string, fnHash func() hash.Hash, separator []byte) ([]byte, error) {
	val, err := unsign(secret, cookie, salt, fnHash, separator)
	if err != nil {
		return nil, fmt.Errorf("unsign('%s'): %s", string(cookie), err)
	}
	i := bytes.LastIndex(val, separator)
	if i == -1 {
		return nil, fmt.Errorf("expected : in '%s'", string(cookie))
	}
	ts := val[i+1:]
	val = val[:i]
	stamp, err := b62Decode(ts)
	if err != nil {
		return nil, fmt.Errorf("b62Decode: %s", err)
	}
	if time.Unix(stamp, 0).Add(maxAge).Before(now()) {
		return nil, fmt.Errorf("expired timestamp: %d", stamp)
	}
	return val, nil
}
